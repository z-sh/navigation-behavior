<Events startTimestamp="1574205228951" logVersion="0.11.0.201504031625" osName="Windows 10" osVersion="10.0" lineSeparator="\r\n" numMonitors="1" monitorBounds="[0, 0, 1920, 1080]">
  <Command __id="0" _type="ShellBoundsCommand" bounds="[-8, -8, 1936, 1056]" timestamp="5" />
  <Command __id="1" _type="FileOpenCommand" docASTNodeCount="260" docActiveCodeLength="2374" docExpressionCount="151" docLength="3861" projectName="MineSweeper" timestamp="20">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeper.java]]></filePath>
    <snapshot><![CDATA[/*
BUG REPORT #2
MineSweeper has 3 difficulty levels. The size of the board and the number of the mines are different for each level. 
Sometimes, we end up having a smaller number of mines in the game. 
For an easy game, we want to have 10 mines, but sometimes it is 9, 8, or even less.
*/

package logic;
import javax.swing.JOptionPane;
import javax.swing.UIManager;

import presentation.CustomMenu;
import presentation.MineSweeperGui;

/**
 * Main launcher class for MineSweeper, containing all the menus and general
 * prompts
 *
 * @author  KnightMiner
 */

public class MineSweeper {
    // currently running instance of the game
    private static MineSweeperGui gui;

    /**
     * Primary way to boot the game
     * @param args  Default args (unused)
     */
    
    public static void main(String[] args) {
        // High DPI stuff
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        }
        catch(Exception e) {
            e.printStackTrace();
        }

        // load the help panels
        // this has a side effect of loading the icons for the pieces
        Help.load();

        // start the game on easy
        newGame(Difficulty.EASY);
    }

    /**
     * Creates a new MineSweeper game with one of three default sizes or custom
     * @param difficulty Game difficulty
     */
    
    public static void newGame(Difficulty difficulty) {
        // difficulty switch
        MineSweeperBoard board = null;
        switch(difficulty) {
            case EASY:
                board = new MineSweeperBoard(9, 9, 10, 0);
                break;
            case NORMAL:
                board = new MineSweeperBoard(16, 16, 40, 1);
                break;
            case HARD:
                board = new MineSweeperBoard(30, 16, 99, 3);
                break;
            case CUSTOM:
                board = customGame();
                break;
        }

        startGame(board);
    }

    /**
     * Creates a new game with the custom size
     * @return  A board of the custom size
     */
    
    public static MineSweeperBoard customGame() {
        CustomMenu menu = new CustomMenu();

        int result = JOptionPane.showConfirmDialog(null, menu,
                "Custom", JOptionPane.OK_CANCEL_OPTION,
                JOptionPane.PLAIN_MESSAGE);

        // if they pressed OK
        if(result == JOptionPane.OK_OPTION) {
            return menu.createBoard();
        }
        else {
            return null;
        }
    }

    /**
     * Starts a new game with the specified board
     * @param board  Game board to start
     */
    
    public static void startGame(MineSweeperBoard board) {
        // must be a valid board
        if(board != null) {
            // remove the current gui and define the new one
            if(gui != null) {
                gui.dispose();
            }

            // create a new instance
            gui = new MineSweeperGui(board);
        }
    }

    /**
     * List of buttons for the GUI
     */
    
    public enum Difficulty {
        /** Easy game */
        EASY("Easy"),
        /** Normal game */
        NORMAL("Normal"),
        /** Hard game */
        HARD("Expert"),
        /** Custom size and mines from the GUI */
        CUSTOM("Custom");

        // data
        private String label;

        /**
         * Default constructor
         * @param  Button label
         */
        
        Difficulty(String label) {
            this.label = label;
        }

        /**
         * Gets the label for the difficulty
         * @return  Difficulty name
         */
        
        public String getLabel() {
            return label;
        }
    }
}
]]></snapshot>
  </Command>
  <Command __id="2" _type="SelectTextCommand" caretOffset="447" docEnd="831" docOffset="831" docStart="827" end="447" start="443" timestamp="459" />
  <Command __id="3" _type="FileOpenCommand" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19616" projectName="MineSweeper" timestamp="66471">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeperBoard.java]]></filePath>
    <snapshot><![CDATA[package logic;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.*;

import util.Piece;
import util.Space;

/**
 * Contains all the visible pieces in the MineSweeper game
 * 
 * @author KnightMiner
 */

public class MineSweeperBoard implements Serializable {

	/**
	 * Random number generator used to create game seeds Minefields use a sepparate
	 * object created using a specific seed
	 */
	
	public static final Random RANDOM = new Random();

	// resizable
	private transient Queue<Space> update;

	// board dimensions
	private int width, height;
	private MineGenerator data = new MineGenerator();

	private int flagCount;

	// board data
	private Piece[][] pieces;
	private boolean[][] mines;
	private boolean gameOver;
	private boolean victory;

	// determines if the first click happened yet
	private boolean firstClick;

	// determines if we have used our one cheat
	private int cheatsAllowed;
	private int cheats = 0;

	// board seed
	private long seed;

	/**
	 * Creates a new minesweaper board with the specified dimensions
	 * 
	 * @param width     Width of the board
	 * @param height    Height of the board
	 * @param mineCount Total mines
	 * @param cheats    Cheats allowed
	 */
	
	public MineSweeperBoard(int width, int height, int mineCount, int cheats) {
		this.width = width;
		this.height = height;

		this.pieces = new Piece[height][width];
		this.mines = new boolean[height][width];

		// sanity check in case the GUI fails to correct the number
		this.data.mineCount = Math.min(mineCount, width * height - 9);
		this.cheatsAllowed = this.cheats = cheats;

		update = new LinkedList<>();
	}

	/**
	 * Creates a new minesweaper board with the specified dimensions
	 * 
	 * @param width     Width of the board
	 * @param height    Height of the board
	 * @param mineCount Total mines
	 */
	
	public MineSweeperBoard(int width, int height, int mineCount) {
		this(width, height, mineCount, 1);
	}

	/* Main logic */

	/**
	 * Populates the board with mines with a random seed
	 * 
	 * @param space Space clicked
	 */
	
	public void generateMines(Space space) {
		generateMines(RANDOM.nextLong(), space);
	}

	/**
	 * Populates the board with mines
	 * 
	 * @param seed    Seed to generate mines. Two fields with the same size and seed
	 *                will have the same mines locations
	 * @param clicked space clicked when generating the mines
	 */
	
	protected void generateMines(long seed, Space clicked) {
		// store the current seed for saving games
		this.seed = seed;

		// no mines? no work
		if (data.mineCount == 0) {
			return;
		}

		// list of spaces we can still place a mine at
		List<Space> remainingSpaces = new ArrayList<>(Arrays.asList(getAllSpaces()));

		// if we clicked somewhere, remove all nearby spaces
		if (clicked != null) {
			// remove all unclickable spaces
			final int x = clicked.getX(), y = clicked.getY();
			remainingSpaces.removeIf((space) -> {
				return (y - 1) <= space.getY() && space.getY() <= (y + 1) && (x - 1) <= space.getX()
						&& space.getX() <= (x + 1);
			});
		}

		// random object seeded so results can be controlled
		Random random = new Random(seed);

		// place mines
		this.mines = new boolean[height][width];
		for (int i = 0; i < data.mineCount; i++) {
			// just get the linear location of the next mine and place it
			int mine = random.nextInt(remainingSpaces.size());
			Space space = remainingSpaces.get(mine);
			mines[space.getY()][space.getX()] = true;

		}
	}

	/**
	 * Creates a new game with the same dimensions
	 */
	
	public void newGame() {
		// first, regenerate the mines
		this.mines = new boolean[height][width];

		// next, clear game specific data
		resetData();

		// then mark all spaces for a rendering update
		for (Space space : getAllSpaces()) {
			markUpdate(space);
		}
	}

	/**
	 * Restarts the current game
	 */
	
	public void restart() {
		// if we have not clicked yet, do nothing
		// we don't have a seed to restart from
		if (!firstClick) {
			return;
		}

		// reset any relevant data
		resetData();

		// but assume we already clicked so the mines don't change
		firstClick = true;

		// and mark all spaces for an update
		for (Space space : getAllSpaces()) {
			markUpdate(space);
		}
	}

	/**
	 * Saves the board to a binary file
	 * 
	 * @param filename Location of the game
	 */
	
	public void saveGame(String filename) {
		// TODO: better saving logic
		try {
			FileOutputStream file = new FileOutputStream(filename + ".bin");
			ObjectOutputStream stream = new ObjectOutputStream(file);
			stream.writeObject(this);
			stream.flush();
			stream.close();
		} catch (IOException e) {
		}
	}

	/**
	 * Load the board from a binary file
	 * 
	 * @param filename Location of the game
	 * @return The board, or null if invalid
	 */
	
	public static MineSweeperBoard loadGame(String filename) {
		try {
			FileInputStream file = new FileInputStream(filename + ".bin");
			ObjectInputStream stream = new ObjectInputStream(file);
			MineSweeperBoard board = (MineSweeperBoard) stream.readObject();
			stream.close();
			return board;
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Resets generic data
	 */
	
	private void resetData() {
		this.pieces = new Piece[height][width];
		gameOver = false;
		firstClick = false;
		cheats = cheatsAllowed;
		flagCount = 0;
		victory = false;
	}

	/**
	 * Ends the game with a loss
	 * 
	 * @param clicked Location clicked causing the loss
	 * @return Mine clicked
	 */
	
	public void loseGame(Space clicked) {
		// set the game to over
		gameOver = true;

		showMines(clicked, false);
	}

	/**
	 * Checks if the game has been won, and sets the appropiate statuses
	 */
	
	public void checkVictory() {
		// check all spaces
		for (Space space : getAllSpaces()) {

			// only spaces without mines need to be checked, we don't care about
			// flags or marks on mine spaces
			if (!isMine(space)) {
				// if the piece is unclicked or not a number, we failed
				Piece piece = getPiece(space);
				if (piece == null || !piece.isNumber()) {
					return;
				}
			}
		}

		// made it through that? we won
		victory = true;
		gameOver = true;

		showMines(null, true);
	}

	/**
	 * Shows all the mines on the board
	 * 
	 * @param space   Space that was clicked
	 * @param victory Determines if the game was won or lost
	 */
	
	private void showMines(Space clicked, boolean victory) {
		// set the mine color based on victory
		Piece mine = victory ? Piece.MINE_GREEN : Piece.MINE;

		// set the clicked space to red
		if (clicked != null && isMine(clicked)) {
			setPiece(clicked, Piece.MINE_RED);
		}

		// show mines on the board
		for (Space space : getAllSpaces()) {
			if (space.equals(clicked)) {
				continue;
			}
			Piece piece = getPiece(space);
			if (isMine(space)) {
				// but only on empty or marks
				if (piece == null || piece.isMark()) {
					setPiece(space, mine);
				}
			} else {
				// if the space has a flag but no mine, mark it as such
				if (piece == Piece.FLAG) {
					setPiece(space, Piece.FLAG_NOT);
				}
			}
		}
	}

	/* Clicking */

	/**
	 * Handle standard game clicks
	 * 
	 * @param space  Space clicked
	 * @param action Type of click
	 */
	
	public void handleClick(Space space, ClickAction action) {
		// stop playing when the game is over
		if (gameOver) {
			return;
		}
		// simply passes it along to the dedicated function
		switch (action) {
		case DEFAULT:
			handleDefaultClick(space);
			break;
		case FLAG:
			handleFlagClick(space);
			break;
		case MARK:
			handleMarkClick(space);
			break;
		case CHEAT:
			handleCheatClick(space);
			break;
		}
	}

	/**
	 * Space clicking core, does the actual clicking action
	 * 
	 * @param space Space clicked
	 */
	
	private void clickSpace(Space space) {
		// if the space is not replaceable, stop now
		// called here so we don't click flags as they are mines
		if (!isReplaceable(space)) {
			return;
		}

		// if the space is a mine, we lose
		if (isMine(space)) {
			loseGame(space);
		}

		// otherwise do a normal click
		else {
			// sets the piece to the number of surrounding mines
			Piece newPiece = getNumber(space);
			setPiece(space, newPiece);

			// if the piece is 0, update surrounding pieces as none of them are mines
			// this won't eternally recur since this space is no longer clickable
			if (newPiece == Piece.N0) {
				for (Space neighbor : getNeighbors(space)) {
					clickSpace(neighbor);
				}
			}
		}
	}

	/**
	 * Default clicks, clicks a space and displays a number or loses the game
	 * 
	 * @param space Space clicked
	 */
	
	private void handleDefaultClick(Space space) {
		// first click should generate the minefield
		if (!firstClick) {
			firstClick(space);
		}

		// if the space cannot be replaced then stop here
		// as we run this function on every click
		if (isNumber(space)) {
			// if the number of flags around this space is the same as the number
			Space[] neighbors = getNeighbors(space);

			// count the flags around the piece
			int flags = 0;
			for (Space neighbor : neighbors) {
				if (getPiece(neighbor) == Piece.FLAG) {
					flags++;
				}
			}

			// same number of flags as the piece number?
			if (flags == getPiece(space).getNumber()) {
				// click all the spaces. This is a risky move if a flag is wrong
				for (Space neighbor : neighbors) {
					clickSpace(neighbor);
				}
			}
		}
		// otherwise if not a number, just click the space
		else {
			clickSpace(space);
		}

		// check just once at the end of clicking
		checkVictory();
	}

	/**
	 * Handle the first click in the game. This click will generate the minefield as
	 * it cannot be on a mine
	 * 
	 * @param space Space clicked
	 */
	
	private void firstClick(Space space) {
		generateMines(space);
		firstClick = true;
	}

	/**
	 * Flag clicks, essentially click once to add
	 * 
	 * @param space Space clicked
	 */
	
	private void handleFlagClick(Space space) {
		// if already a flag, set a mark
		Piece piece = getPiece(space);
		if (piece == Piece.FLAG) {
			setPiece(space, Piece.MARK_RED);
			flagCount--;
		}
		// remove marks
		else if (piece != null && piece.isMark()) {
			setPiece(space, null);
		}
		// otherwise if we can add one
		else if (isReplaceable(space)) {
			if(flagCount < data.mineCount) {
				setPiece(space, Piece.FLAG);
				flagCount++;
			}
		}
	}

	/**
	 * Mark clicks, changes the color of a mark
	 * 
	 * @param space Space clicked
	 */
	
	private void handleMarkClick(Space space) {
		// tobble the mark
		Piece piece = getPiece(space);
		if (piece == Piece.MARK_RED) {
			setPiece(space, Piece.MARK_GREEN);
		}
		// remove marks
		else if (piece == Piece.MARK_GREEN) {
			setPiece(space, Piece.MARK_BLUE);
		}
		// otherwise if we can add one
		else if (piece == Piece.MARK_BLUE) {
			setPiece(space, Piece.MARK_RED);
		}

		// if its a flag, remove it
		else if (piece == Piece.FLAG) {
			setPiece(space, Piece.MARK_RED);
			flagCount--;
		}

		// essentially all that is left here is null, but still
		else if (isReplaceable(space)) {
			setPiece(space, Piece.MARK_RED);
		}
	}

	/**
	 * Cheat clicks, click a space and it will show a "ghost" bomb if one exists
	 * 
	 * @param space Space clicked
	 */
	
	private void handleCheatClick(Space space) {
		// already ran, don't run again
		if (!canCheat()) {
			return;
		}

		// no mines if we have not clicked
		if (!firstClick) {
			// you cheated for the first click, useless move as now we don't care
			// about click protection
			firstClick(null);
		}

		// only marks and empty spaces can be cheated, to save accidental clicks
		Piece piece = getPiece(space);
		if (piece != null && !piece.isMark()) {
			return;
		}

		// if its a mine, show that
		if (isMine(space)) {
			setPiece(space, Piece.MINE_GREEN);
		}
		// otherwise click the space as we know its safe
		else {
			clickSpace(space);
		}

		// use a cheat
		cheats--;

		// need to check, since it could be the last click
		checkVictory();
	}

	/* Helper functions */

	/**
	 * Gets a list of all spaces
	 * 
	 * @return a list of all spaces
	 */
	
	public Space[] getAllSpaces() {
		Space[] spaces = new Space[width * height];

		// loop through all spaces, adding them to an array
		int i = 0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				spaces[i] = new Space(x, y);
				i++;
			}
		}

		return spaces;
	}

	/**
	 * Helper function to get the coordinates of all 8 neighbors to the space Note
	 * that some may be invalid spaces
	 * 
	 * @param space Space around which to get neighbors
	 * @return an array of spaces of the 8 neighbors, or less on edges
	 */
	
	public Space[] getNeighbors(Space space) {
		// if not valid, return no neighbors
		if (!isValid(space)) {
			return new Space[0];
		}

		// array cannot be bigger than 8
		Space[] neighbors = new Space[8];
		int x = space.getX();
		int y = space.getY();

		// 2D loop from x - 1, y - 1 up to x + 1, y + 1
		int neighborCount = 0;
		for (int i = -1; i <= 1; i++) {
			for (int j = -1; j <= 1; j++) {
				// skip offset of 0,0 as that is the input space
				if (i == 0 && j == 0) {
					continue;
				}

				// make sure the space is valid before returning it
				Space neighbor = new Space(x + i, y + j);
				if (isValid(neighbor)) {
					neighbors[neighborCount] = neighbor;
					neighborCount++;
				}
			}
		}

		return neighbors;
	}

	/**
	 * Marks a space as needing update by the graphics display
	 * 
	 * @param space space needing an update
	 */
	
	public void markUpdate(Space space) {
		if (!update.contains(space)) {
			update.add(space);
		}
	}

	/**
	 * Returns the number to display on the space after clicking it Does not take
	 * bombs on this space into account, check isMine() first
	 * 
	 * @param space Space to check
	 * @return The number of bombs around this space
	 */
	
	public Piece getNumber(Space space) {
		// no space? no return
		if (!isValid(space)) {
			return null;
		}

		int count = 0;
		// check all the neighbors for a bomb
		for (Space neighbor : getNeighbors(space)) {
			// if they have one, add to the running total
			if (isMine(neighbor)) {
				count++;
			}
		}

		// return the specific piece
		return Piece.fromNumber(count);
	}

	/* Getters, setters, and basic return logic */

	/**
	 * Gets the piece on the specified space
	 * 
	 * @param space Space to check for a piece
	 * @return the piece on the specified space
	 */
	
	public Piece getPiece(Space space) {
		// invalid gets null
		if (!isValid(space)) {
			return null;
		}

		// otherwise go with the contained piece
		return pieces[space.getY()][space.getX()];
	}

	/**
	 * Placed a piece on a space
	 * 
	 * @param space Space to place the piece
	 * @param piece Piece to place on the space
	 */
	
	public void setPiece(Space space, Piece piece) {
		// must be valid
		if (isValid(space)) {
			pieces[space.getY()][space.getX()] = piece;
			markUpdate(space);
		}
	}

	/**
	 * Determines if a space contains a bomb
	 * 
	 * @param space Space to check
	 * @return True if the space contains a bomb
	 */
	
	public boolean isMine(Space space) {
		// not a valid space?
		if (!isValid(space)) {
			return false;
		}

		return mines[space.getY()][space.getX()];
	}

	/**
	 * Determines if a space appears enabled, or pressed up
	 * 
	 * @param space Space to check
	 * @return True if the space appears enabled
	 */
	
	public boolean isEnabled(Space space) {
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it pops up
		if (piece == null) {
			return true;
		}

		// otherwise go based on the contained value
		return piece.isEnabled();
	}

	/**
	 * Determines if the contents of a space can be replaced
	 * 
	 * @param space Space clicked
	 */
	
	private boolean isReplaceable(Space space) {
		// invalid spaces are always false
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it can be clicked
		if (piece == null) {
			return true;
		}

		// otherwise go based on the contained value
		return piece.isReplaceable();
	}

	/**
	 * Determines if the space is a number
	 * 
	 * @param space Space clicked
	 */
	
	private boolean isNumber(Space space) {
		// invalid spaces are always false
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it is not a number
		if (piece == null) {
			return false;
		}

		// otherwise go based on the contained value
		return piece.isNumber();
	}

	/* Data */

	/**
	 * Gets the width of the board
	 * 
	 * @return The width of the board
	 */
	
	public int getWidth() {
		return width;
	}

	/**
	 * Gets the height of the board
	 * 
	 * @return The height of the board
	 */
	
	public int getHeight() {
		return height;
	}

	/**
	 * Gets the number of mines left on the board
	 * 
	 * @return number of mines remaining
	 */
	
	public int getRemainingMines() {
		return data.mineCount - flagCount;
	}

	/**
	 * Checks if the player has used their cheat
	 * 
	 * @return if the player has used their cheat
	 */
	
	public boolean canCheat() {
		return cheats > 0;
	}

	/**
	 * Checks how many cheats the player has left
	 * 
	 * @return remaining cheats
	 */
	
	public int getCheats() {
		return cheats;
	}

	/**
	 * Checks if the game ended
	 * 
	 * @return true if the game ended
	 */
	
	public boolean gameOver() {
		return gameOver;
	}

	/**
	 * Checks if the player won the game
	 * 
	 * @return true if the player won the game
	 */
	
	public boolean hasWon() {
		return victory;
	}

	/**
	 * Checks if a space is within the bounds of this board
	 * 
	 * @param space Space to check
	 * @return true if the space is within this board
	 */
	
	public boolean isValid(Space space) {
		// no space?
		if (space == null) {
			return false;
		}

		// first, check if the space is entirely invalid
		if (space.getX() < 0 || space.getY() < 0) {
			return false;
		}

		// next, check if this is outside of this board
		if (space.getY() >= height || space.getX() >= width) {
			return false;
		}

		// fits in both? return true then
		return true;
	}

	/**
	 * Gets a list of spaces pending updates to update the button displays
	 * 
	 * @return a list of spaces needing an update
	 */
	
	public Queue<Space> getUpdates() {
		return update;
	}

	/**
	 * Actions that can be performed on click. Used by buttons to pass along a
	 * constant rather than a list of modifiers.
	 */
	
	public enum ClickAction {
		/** Normal click */
		DEFAULT,
		/** Placing a flag or mark */
		FLAG,
		/** Placing a mark of different colors */
		MARK,
		/** Safely clicking a mine */
		CHEAT;
	}
}
]]></snapshot>
  </Command>
  <Command __id="4" _type="MoveCaretCommand" caretOffset="0" docOffset="0" timestamp="66547" />
  <Command __id="5" _type="FileOpenCommand" docASTNodeCount="411" docActiveCodeLength="6406" docExpressionCount="283" docLength="7197" projectName="MineSweeper" timestamp="68035">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\Help.java]]></filePath>
    <snapshot><![CDATA[package logic;
import java.awt.GridLayout;
import java.awt.Image;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import util.Piece;

/**
 * Contains methods to load various help panels
 * 
 * @author  KnightMiner
 */

public class Help {
    // prebuilt panels
    private static RulesPanel rulesPanel;
    private static DifficultyPanel difficultyPanel;
    private static MenuPanel menuPanel;

    /**
     * Called by MineSweeper to create all the help panels
     */
    
    public static void load() {
        // create panels
        rulesPanel = new RulesPanel();
        difficultyPanel = new DifficultyPanel();
        menuPanel = new MenuPanel();
    }

    /**
     * Show the main rules help panel
     * @param parent  Currently open GUI
     */
    
    public static void showRules(JFrame parent) {
        JOptionPane.showMessageDialog(parent, rulesPanel, "MineSweeper - Rules", JOptionPane.PLAIN_MESSAGE);
    }

    /**
     * Show the GUI help panel
     * @param parent  Currently open GUI
     */
    
    public static void difficultyHelp(JFrame parent) {
        JOptionPane.showMessageDialog(parent, difficultyPanel, "MineSweeper - Difficulty", JOptionPane.PLAIN_MESSAGE);
    }

    /**
     * Show the GUI help panel
     * @param parent  Currently open GUI
     */
    
    public static void menuHelp(JFrame parent) {
        JOptionPane.showMessageDialog(parent, menuPanel, "MineSweeper - Menu help", JOptionPane.PLAIN_MESSAGE);

    }

    /**
     * Panel describing the game
     */
    
    private static class RulesPanel extends JPanel {
        public RulesPanel() {

            setLayout(new GridLayout(3, 2));

            // empty
            add(new IconDescription(Piece.N0, "Empty spaces can be clicked to reveal mines and numbers. "
                    + "The first click of a game is safe, but after that it may be a mine."));

            // goal
            add(new IconDescription(Piece.MARK_GREEN,
                    "The goal of the game is to click all safe spaces without clicking any mines."));

            // mines
            add(new IconDescription(Piece.MINE,
                    "If you click a space with a mine, you lose and all other mines are revealed."));

            // numbers
            add(new IconDescription(Piece.N6,
                    "When a space is safe, clicking it will reveal a number which tells tells how many mines are adjectent to the number. "
                            + "They could be horizontally, vertically, or diagonally adjectent.",
                    "If a number has the same number of flags around it, it can be clicked to click all open spaces around it."));

            // flags
            add(new IconDescription(Piece.FLAG,
                    "Right clicking a space will place a flag, to mark the location of a mine. "
                            + "Flags prevents you from accidently clicking a mine, and decreases the remaining mine count.",
                    "Right clicking a flag will remove it, replacing it with a mark."));

            // marks
            add(new IconDescription(Piece.MARK_RED,
                    "Marks are placed by right clicking a flag, or holding shift and right clicking and empty space. "
                            + "They are used just to mark possible mines. Unlike flags, they can still be clicked.",
                    "Right clicking a mark will remove it."));
        }
    }

    /**
     * Panel about navigating the menus
     */
    
    private static class DifficultyPanel extends JPanel {
        public DifficultyPanel() {
            // 4 panels
            setLayout(new GridLayout(4, 1));

            // easy
            add(new IconDescription(Piece.FLAG, "In an easy game, the board is 9x9 and there are only 10 mines.",
                    "This size is recommended for beginners and can be completed quickly as skill progresses."));

            // normal
            add(new IconDescription(Piece.N4, "In a normal game, the board is 16x16 and has 40 mines.",
                    "This size is recommended for a player hoping to advance their skills, "
                            + "or as a more relaxing game after many trys in expert."));

            // hard
            add(new IconDescription(Piece.MINE, "In an expert game, the board is 30x16 and has 99 mines. "
                    + "This size is a challenge even for the best of players, games can easily take 30 minutes."));

            // custom
            add(new IconDescription(Piece.MARK_BLUE,
                    "Custom games allow the player to choose the size from 5x5 to 50x50, "
                            + "as well as the mine count. This allows making a vareity of difficult from easy to impossible."));
        }
    }

    private static class MenuPanel extends JPanel {
        public MenuPanel() {
            add(new IconDescription(null, "The big new game ubtton will simply start a new game at the current size.",
                    "This button will also change its label to denote winning and losing.", "",
                    "The new game menu allows starting the game in three different difficulties, along with a customizer.",
                    "",
                    "Restart will restart the current game from the beginning, removing all revealed numbers and "
                            + "placed flags and marks without changing the minefield.",
                    "Note that when restarting the first click is no longer gaurenteed to be safe.", "",
                    "Save game and load game allow you to save a game to the disc and resume at a later time.", "",
                    "The menu bar shows the number of mines left unmarked, which decreases whenever you place a flag.",
                    "Note that this will increment even if there is no mine under the flag, too many flags will make it negative.",
                    "",
                    "Clicking the cheat button will allow you to safely click a space. "
                            + "If the space is a mine, it will mark it with a green mine, but you won't lose. "
                            + "If it is safe, it will act like clicking a normal space.",
                    "Each game has limited cheats, so use sparingly."));
        }
    }

    /**
     * Helper class to add multiline text with images
     */
    
    private static class IconDescription extends JLabel {
        public IconDescription(Piece piece, String... text) {
            // add newlines to the text array
            setText("<html><body style='width:400px;'>" + String.join("<br>", text) + "</body></html>");

            // if a piece is set, use that as the icon
            if (piece != null && piece.getIcon() != null) {
                Image image = piece.getIcon().getScaledInstance(32, 32, Image.SCALE_SMOOTH);
                setIcon(new ImageIcon(image));
            }
        }
    }
}
]]></snapshot>
  </Command>
  <Command __id="6" _type="MoveCaretCommand" caretOffset="0" docOffset="0" timestamp="68147" />
  <Command __id="7" _type="FileOpenCommand" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19616" projectName="MineSweeper" timestamp="71026">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeperBoard.java]]></filePath>
  </Command>
  <Command __id="8" _type="FileOpenCommand" docASTNodeCount="411" docActiveCodeLength="6406" docExpressionCount="283" docLength="7197" projectName="MineSweeper" timestamp="71066">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\Help.java]]></filePath>
  </Command>
  <Command __id="9" _type="MoveCaretCommand" caretOffset="0" docOffset="0" timestamp="71180" />
  <Command __id="10" _type="MoveCaretCommand" caretOffset="0" docOffset="0" timestamp="71181" />
  <Command __id="11" _type="FileOpenCommand" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19616" projectName="MineSweeper" timestamp="73111">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeperBoard.java]]></filePath>
  </Command>
  <Command __id="12" _type="MoveCaretCommand" caretOffset="0" docOffset="0" timestamp="73180" />
  <Command __id="13" _type="FileOpenCommand" docASTNodeCount="260" docActiveCodeLength="2374" docExpressionCount="151" docLength="3861" projectName="MineSweeper" timestamp="80933">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeper.java]]></filePath>
  </Command>
  <Command __id="14" _type="SelectTextCommand" caretOffset="728" docEnd="831" docOffset="831" docStart="827" end="728" start="724" timestamp="80976" />
  <Command __id="15" _type="SelectTextCommand" caretOffset="593" docEnd="696" docOffset="696" docStart="661" end="593" start="558" timestamp="90281" />
  <Command __id="16" _type="MoveCaretCommand" caretOffset="604" docOffset="707" timestamp="90721" />
  <Command __id="17" _type="RunCommand" kind="Create" projectName="MineSweeper" timestamp="101080" type="Run" />
  <Command __id="18" _type="RunCommand" exitValue="0" kind="Terminate" projectName="MineSweeper" timestamp="107706" type="Run" />
  <Command __id="19" _type="FileOpenCommand" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19616" projectName="MineSweeper" timestamp="110834">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeperBoard.java]]></filePath>
  </Command>
  <Command __id="20" _type="MoveCaretCommand" caretOffset="0" docOffset="0" timestamp="110869" />
  <Command __id="21" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" start_end="START" timestamp="125940" />
  <Command __id="22" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" timestamp="126081" />
  <Command __id="23" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" start_end="END" timestamp="127839" />
  <Command __id="24" _type="MoveCaretCommand" caretOffset="292" docOffset="519" timestamp="142529" />
  <Command __id="25" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" repeat="2" timestamp="143692" timestamp2="143693" />
  <DocumentChange __id="27" _type="Delete" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19615" endLine="22" length="1" offset="519" startLine="22" timestamp="144137">
    <text><![CDATA[p]]></text>
  </DocumentChange>
  <Command __id="28" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" repeat="2" timestamp="144145" timestamp2="144145" />
  <Command __id="30" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" timestamp="146602" />
  <Command __id="31" _type="MoveCaretCommand" caretOffset="385" docOffset="612" timestamp="149385" />
  <Command __id="32" _type="FileOpenCommand" docASTNodeCount="43" docActiveCodeLength="235" docExpressionCount="27" docLength="235" projectName="MineSweeper" timestamp="237447">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineGenerator.java]]></filePath>
    <snapshot><![CDATA[package logic;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import util.Space;

public class MineGenerator {
	public int mineCount;

	public MineGenerator() {
	}
}]]></snapshot>
  </Command>
  <Command __id="33" _type="MoveCaretCommand" caretOffset="0" docOffset="0" timestamp="237521" />
  <Command __id="34" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" start_end="START" timestamp="244781" />
  <Command __id="35" _type="EclipseCommand" commandID="AUTOGEN:::org.eclipse.jdt.internal.ui.CompilationUnitEditor.ruler.actions/org.eclipse.jdt.internal.ui.javaeditor.JavaSelectRulerAction" timestamp="244810" />
  <Command __id="36" _type="AssistCommand" assist_type="QUICK_ASSIST" auto_activated="false" start_end="END" timestamp="248550" />
  <Command __id="37" _type="MoveCaretCommand" caretOffset="77" docOffset="175" timestamp="255329" />
  <Command __id="38" _type="FileOpenCommand" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19615" projectName="MineSweeper" timestamp="259469">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeperBoard.java]]></filePath>
  </Command>
  <Command __id="39" _type="MoveCaretCommand" caretOffset="385" docOffset="612" timestamp="259504" />
  <Command __id="40" _type="FileOpenCommand" docASTNodeCount="260" docActiveCodeLength="2374" docExpressionCount="151" docLength="3861" projectName="MineSweeper" timestamp="260001">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeper.java]]></filePath>
  </Command>
  <Command __id="41" _type="MoveCaretCommand" caretOffset="604" docOffset="707" timestamp="260038" />
  <Command __id="42" _type="RunCommand" kind="Create" projectName="MineSweeper" timestamp="267655" type="Run" />
  <Command __id="43" _type="RunCommand" exitValue="0" kind="Terminate" projectName="MineSweeper" timestamp="292395" type="Run" />
  <Command __id="44" _type="FileOpenCommand" docASTNodeCount="411" docActiveCodeLength="6406" docExpressionCount="283" docLength="7197" projectName="MineSweeper" timestamp="302183">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\Help.java]]></filePath>
  </Command>
  <Command __id="45" _type="MoveCaretCommand" caretOffset="0" docOffset="0" timestamp="302245" />
  <Command __id="46" _type="RunCommand" kind="Create" projectName="MineSweeper" timestamp="336848" type="Run" />
  <Command __id="47" _type="MoveCaretCommand" caretOffset="2207" docOffset="2403" timestamp="403577" />
  <Command __id="48" _type="RunCommand" exitValue="0" kind="Terminate" projectName="MineSweeper" timestamp="474062" type="Run" />
  <Command __id="50" _type="FileOpenCommand" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19615" projectName="MineSweeper" timestamp="483413">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeperBoard.java]]></filePath>
  </Command>
  <Command __id="51" _type="MoveCaretCommand" caretOffset="385" docOffset="612" timestamp="483447" />
  <Command __id="52" _type="MoveCaretCommand" caretOffset="5855" docOffset="6082" timestamp="496505" />
  <DocumentChange __id="53" _type="Insert" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19616" length="1" offset="6082" timestamp="497580">
    <text><![CDATA[r]]></text>
  </DocumentChange>
  <Command __id="54" _type="InsertStringCommand" repeat="2" timestamp="497584" timestamp2="497584">
    <data><![CDATA[rr]]></data>
  </Command>
  <Command __id="56" _type="MoveCaretCommand" caretOffset="5909" docOffset="6136" timestamp="498113" />
  <Command __id="57" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" timestamp="498943" />
  <Command __id="59" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="6136" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="533327" wrapSearch="true">
    <searchString><![CDATA[victory]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="60" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="6561" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="533876" wrapSearch="true">
    <searchString><![CDATA[victory]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="61" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="6840" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="535806" wrapSearch="true">
    <searchString><![CDATA[victory]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="62" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="10086" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="537172" wrapSearch="true">
    <searchString><![CDATA[victory]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="63" _type="MoveCaretCommand" caretOffset="9851" docOffset="10078" timestamp="561633" />
  <Command __id="64" _type="MoveCaretCommand" caretOffset="9693" docOffset="9920" timestamp="562577" />
  <Command __id="66" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="9920" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="570757" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="67" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="12619" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="571325" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="68" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="6134" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="572083" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="69" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="10088" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="575228" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="70" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="12619" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="576060" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="71" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="6134" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="576899" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="72" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="10088" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="577732" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="73" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="12619" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="578349" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="74" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="6134" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="580635" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="75" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="10088" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="600349" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="76" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="12619" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="609260" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="77" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="6134" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="610475" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="78" _type="FindCommand" caseSensitive="false" forward="true" matchWord="false" offset="10088" regexp="false" replaceAll="false" selection="Find" selectionScope="false" timestamp="614156" wrapSearch="true">
    <searchString><![CDATA[checkVictory()]]></searchString>
    <replaceString><![CDATA[]]></replaceString>
  </Command>
  <Command __id="79" _type="RunCommand" kind="Create" projectName="MineSweeper" timestamp="623482" type="Run" />
  <Command __id="80" _type="MoveCaretCommand" caretOffset="12257" docOffset="12484" timestamp="744729" />
  <Command __id="81" _type="MoveCaretCommand" caretOffset="10861" docOffset="11088" timestamp="777816" />
  <Command __id="82" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.COLUMN_NEXT" repeat="2" timestamp="779188" timestamp2="779188" />
  <DocumentChange __id="84" _type="Delete" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19614" endLine="464" length="2" offset="11087" repeat="2" startLine="464" timestamp="779524" timestamp2="779637">
    <text><![CDATA[bb]]></text>
  </DocumentChange>
  <Command __id="85" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" repeat="4" timestamp="779529" timestamp2="779639" />
  <DocumentChange __id="90" _type="Insert" docASTNodeCount="1769" docActiveCodeLength="10590" docExpressionCount="1040" docLength="19616" length="2" offset="11087" repeat="2" timestamp="779965" timestamp2="780141">
    <text><![CDATA[gg]]></text>
  </DocumentChange>
  <Command __id="91" _type="InsertStringCommand" repeat="4" timestamp="779968" timestamp2="780144">
    <data><![CDATA[gggg]]></data>
  </Command>
  <Command __id="96" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" timestamp="781542" />
  <Command __id="97" _type="MoveCaretCommand" caretOffset="8975" docOffset="9202" timestamp="833681" />
  <Command __id="98" _type="MoveCaretCommand" caretOffset="10700" docOffset="10927" timestamp="904289" />
  <Command __id="99" _type="MoveCaretCommand" caretOffset="10503" docOffset="10730" timestamp="906480" />
  <Command __id="100" _type="MoveCaretCommand" caretOffset="10530" docOffset="10757" timestamp="907080" />
  <Command __id="101" _type="MoveCaretCommand" caretOffset="10432" docOffset="10659" timestamp="908257" />
  <Command __id="102" _type="MoveCaretCommand" caretOffset="10273" docOffset="10500" timestamp="910056" />
  <Command __id="103" _type="MoveCaretCommand" caretOffset="10700" docOffset="10927" timestamp="911625" />
  <DocumentChange __id="104" _type="Insert" docASTNodeCount="1769" docActiveCodeLength="10594" docExpressionCount="1040" docLength="19620" length="4" offset="10927" timestamp="920578">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="105" _type="InsertStringCommand" timestamp="920585">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="106" _type="InsertStringCommand" timestamp="920585">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="107" _type="Insert" docASTNodeCount="1769" docActiveCodeLength="10598" docExpressionCount="1040" docLength="19624" length="4" offset="10931" timestamp="920733">
    <text><![CDATA[
		]]></text>
  </DocumentChange>
  <Command __id="108" _type="InsertStringCommand" timestamp="920736">
    <data><![CDATA[]]></data>
  </Command>
  <Command __id="109" _type="InsertStringCommand" timestamp="920737">
    <data><![CDATA[]]></data>
  </Command>
  <DocumentChange __id="110" _type="Insert" docASTNodeCount="1771" docActiveCodeLength="10604" docExpressionCount="1041" docLength="19630" length="6" offset="10935" repeat="6" timestamp="921306" timestamp2="922645">
    <text><![CDATA[checkV]]></text>
  </DocumentChange>
  <Command __id="111" _type="InsertStringCommand" repeat="12" timestamp="921309" timestamp2="922647">
    <data><![CDATA[cchheecckkVV]]></data>
  </Command>
  <DocumentChange __id="128" _type="Insert" docASTNodeCount="1772" docActiveCodeLength="10613" docExpressionCount="1042" docLength="19639" length="9" offset="10941" repeat="8" timestamp="931776" timestamp2="935075">
    <text><![CDATA[ictory();]]></text>
  </DocumentChange>
  <Command __id="129" _type="InsertStringCommand" repeat="18" timestamp="931778" timestamp2="935078">
    <data><![CDATA[iiccttoorryy(());;]]></data>
  </Command>
  <Command __id="154" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" timestamp="937017" />
  <Command __id="155" _type="RunCommand" kind="Create" projectName="MineSweeper" timestamp="940155" type="Run" />
  <Command __id="156" _type="RunCommand" exitValue="0" kind="Terminate" projectName="MineSweeper" timestamp="943751" type="Run" />
  <Command __id="157" _type="RunCommand" exitValue="0" kind="Terminate" projectName="MineSweeper" timestamp="946403" type="Run" />
  <Command __id="158" _type="RunCommand" kind="Create" projectName="MineSweeper" timestamp="949240" type="Run" />
  <Command __id="159" _type="RunCommand" exitValue="0" kind="Terminate" projectName="MineSweeper" timestamp="1106797" type="Run" />
  <Command __id="160" _type="MoveCaretCommand" caretOffset="10708" docOffset="10935" timestamp="1108121" />
  <DocumentChange __id="161" _type="Insert" docASTNodeCount="1772" docActiveCodeLength="10614" docExpressionCount="1042" docLength="19640" length="1" offset="10935" timestamp="1108928">
    <text><![CDATA[#]]></text>
  </DocumentChange>
  <Command __id="162" _type="InsertStringCommand" repeat="2" timestamp="1108932" timestamp2="1108932">
    <data><![CDATA[##]]></data>
  </Command>
  <DocumentChange __id="164" _type="Delete" docASTNodeCount="1772" docActiveCodeLength="10613" docExpressionCount="1042" docLength="19639" endLine="456" length="1" offset="10935" startLine="456" timestamp="1110179">
    <text><![CDATA[#]]></text>
  </DocumentChange>
  <Command __id="165" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" repeat="2" timestamp="1110180" timestamp2="1110180" />
  <DocumentChange __id="167" _type="Insert" docASTNodeCount="1772" docActiveCodeLength="10615" docExpressionCount="1042" docLength="19641" length="2" offset="10935" repeat="2" timestamp="1110804" timestamp2="1110956">
    <text><![CDATA[##]]></text>
  </DocumentChange>
  <Command __id="168" _type="InsertStringCommand" repeat="4" timestamp="1110808" timestamp2="1110959">
    <data><![CDATA[####]]></data>
  </Command>
  <DocumentChange __id="173" _type="Delete" docASTNodeCount="1772" docActiveCodeLength="10613" docExpressionCount="1042" docLength="19639" endLine="456" length="2" offset="10935" repeat="2" startLine="456" timestamp="1111653" timestamp2="1111815">
    <text><![CDATA[##]]></text>
  </DocumentChange>
  <Command __id="174" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" repeat="4" timestamp="1111654" timestamp2="1111817" />
  <DocumentChange __id="179" _type="Insert" docASTNodeCount="1769" docActiveCodeLength="10598" docExpressionCount="1040" docLength="19641" length="2" offset="10935" repeat="2" timestamp="1112888" timestamp2="1112995">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="180" _type="InsertStringCommand" repeat="4" timestamp="1112890" timestamp2="1112998">
    <data><![CDATA[////]]></data>
  </Command>
  <Command __id="185" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" timestamp="1114294" />
  <Command __id="186" _type="RunCommand" kind="Create" projectName="MineSweeper" timestamp="1116085" type="Run" />
  <Command __id="187" _type="RunCommand" exitValue="0" kind="Terminate" projectName="MineSweeper" timestamp="1226490" type="Run" />
  <DocumentChange __id="188" _type="Delete" docASTNodeCount="1772" docActiveCodeLength="10613" docExpressionCount="1042" docLength="19639" endLine="456" length="2" offset="10935" repeat="2" startLine="456" timestamp="1227453" timestamp2="1227603">
    <text><![CDATA[//]]></text>
  </DocumentChange>
  <Command __id="189" _type="EclipseCommand" commandID="eventLogger.styledTextCommand.DELETE_PREVIOUS" repeat="4" timestamp="1227458" timestamp2="1227605" />
  <Command __id="194" _type="EclipseCommand" commandID="org.eclipse.ui.file.save" timestamp="1228007" />
  <Command __id="195" _type="RunCommand" kind="Create" projectName="MineSweeper" timestamp="1229475" type="Run" />
  <Command __id="196" _type="RunCommand" exitValue="0" kind="Terminate" projectName="MineSweeper" timestamp="1243439" type="Run" />
  <Command __id="197" _type="MoveCaretCommand" caretOffset="11027" docOffset="11254" timestamp="1253233" />
  <Command __id="198" _type="MoveCaretCommand" caretOffset="10723" docOffset="10950" timestamp="1254520" />
  <Command __id="199" _type="MoveCaretCommand" caretOffset="10564" docOffset="10791" timestamp="1332016" />
  <DocumentChange __id="200" _type="Delete" docASTNodeCount="56" docActiveCodeLength="423" docExpressionCount="42" docLength="520" endLine="879" length="19119" offset="520" startLine="0" timestamp="1332229">
    <text><![CDATA[arate
	 * object created using a specific seed
	 */
	
	public static final Random RANDOM = new Random();

	// resizable
	private transient Queue<Space> update;

	// board dimensions
	private int width, height;
	private MineGenerator data = new MineGenerator();

	private int flagCount;

	// board data
	private Piece[][] pieces;
	private boolean[][] mines;
	private boolean gameOver;
	private boolean victory;

	// determines if the first click happened yet
	private boolean firstClick;

	// determines if we have used our one cheat
	private int cheatsAllowed;
	private int cheats = 0;

	// board seed
	private long seed;

	/**
	 * Creates a new minesweaper board with the specified dimensions
	 * 
	 * @param width     Width of the board
	 * @param height    Height of the board
	 * @param mineCount Total mines
	 * @param cheats    Cheats allowed
	 */
	
	public MineSweeperBoard(int width, int height, int mineCount, int cheats) {
		this.width = width;
		this.height = height;

		this.pieces = new Piece[height][width];
		this.mines = new boolean[height][width];

		// sanity check in case the GUI fails to correct the number
		this.data.mineCount = Math.min(mineCount, width * height - 9);
		this.cheatsAllowed = this.cheats = cheats;

		update = new LinkedList<>();
	}

	/**
	 * Creates a new minesweaper board with the specified dimensions
	 * 
	 * @param width     Width of the board
	 * @param height    Height of the board
	 * @param mineCount Total mines
	 */
	
	public MineSweeperBoard(int width, int height, int mineCount) {
		this(width, height, mineCount, 1);
	}

	/* Main logic */

	/**
	 * Populates the board with mines with a random seed
	 * 
	 * @param space Space clicked
	 */
	
	public void generateMines(Space space) {
		generateMines(RANDOM.nextLong(), space);
	}

	/**
	 * Populates the board with mines
	 * 
	 * @param seed    Seed to generate mines. Two fields with the same size and seed
	 *                will have the same mines locations
	 * @param clicked space clicked when generating the mines
	 */
	
	protected void generateMines(long seed, Space clicked) {
		// store the current seed for saving games
		this.seed = seed;

		// no mines? no work
		if (data.mineCount == 0) {
			return;
		}

		// list of spaces we can still place a mine at
		List<Space> remainingSpaces = new ArrayList<>(Arrays.asList(getAllSpaces()));

		// if we clicked somewhere, remove all nearby spaces
		if (clicked != null) {
			// remove all unclickable spaces
			final int x = clicked.getX(), y = clicked.getY();
			remainingSpaces.removeIf((space) -> {
				return (y - 1) <= space.getY() && space.getY() <= (y + 1) && (x - 1) <= space.getX()
						&& space.getX() <= (x + 1);
			});
		}

		// random object seeded so results can be controlled
		Random random = new Random(seed);

		// place mines
		this.mines = new boolean[height][width];
		for (int i = 0; i < data.mineCount; i++) {
			// just get the linear location of the next mine and place it
			int mine = random.nextInt(remainingSpaces.size());
			Space space = remainingSpaces.get(mine);
			mines[space.getY()][space.getX()] = true;

		}
	}

	/**
	 * Creates a new game with the same dimensions
	 */
	
	public void newGame() {
		// first, regenerate the mines
		this.mines = new boolean[height][width];

		// next, clear game specific data
		resetData();

		// then mark all spaces for a rendering update
		for (Space space : getAllSpaces()) {
			markUpdate(space);
		}
	}

	/**
	 * Restarts the current game
	 */
	
	public void restart() {
		// if we have not clicked yet, do nothing
		// we don't have a seed to restart from
		if (!firstClick) {
			return;
		}

		// reset any relevant data
		resetData();

		// but assume we already clicked so the mines don't change
		firstClick = true;

		// and mark all spaces for an update
		for (Space space : getAllSpaces()) {
			markUpdate(space);
		}
	}

	/**
	 * Saves the board to a binary file
	 * 
	 * @param filename Location of the game
	 */
	
	public void saveGame(String filename) {
		// TODO: better saving logic
		try {
			FileOutputStream file = new FileOutputStream(filename + ".bin");
			ObjectOutputStream stream = new ObjectOutputStream(file);
			stream.writeObject(this);
			stream.flush();
			stream.close();
		} catch (IOException e) {
		}
	}

	/**
	 * Load the board from a binary file
	 * 
	 * @param filename Location of the game
	 * @return The board, or null if invalid
	 */
	
	public static MineSweeperBoard loadGame(String filename) {
		try {
			FileInputStream file = new FileInputStream(filename + ".bin");
			ObjectInputStream stream = new ObjectInputStream(file);
			MineSweeperBoard board = (MineSweeperBoard) stream.readObject();
			stream.close();
			return board;
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Resets generic data
	 */
	
	private void resetData() {
		this.pieces = new Piece[height][width];
		gameOver = false;
		firstClick = false;
		cheats = cheatsAllowed;
		flagCount = 0;
		victory = false;
	}

	/**
	 * Ends the game with a loss
	 * 
	 * @param clicked Location clicked causing the loss
	 * @return Mine clicked
	 */
	
	public void loseGame(Space clicked) {
		// set the game to over
		gameOver = true;

		showMines(clicked, false);
	}

	/**
	 * Checks if the game has been won, and sets the appropriate statuses
	 */
	
	public void checkVictory() {
		// check all spaces
		for (Space space : getAllSpaces()) {

			// only spaces without mines need to be checked, we don't care about
			// flags or marks on mine spaces
			if (!isMine(space)) {
				// if the piece is unclicked or not a number, we failed
				Piece piece = getPiece(space);
				if (piece == null || !piece.isNumber()) {
					return;
				}
			}
		}

		// made it through that? we won
		victory = true;
		gameOver = true;

		showMines(null, true);
	}

	/**
	 * Shows all the mines on the board
	 * 
	 * @param space   Space that was clicked
	 * @param victory Determines if the game was won or lost
	 */
	
	private void showMines(Space clicked, boolean victory) {
		// set the mine color based on victory
		Piece mine = victory ? Piece.MINE_GREEN : Piece.MINE;

		// set the clicked space to red
		if (clicked != null && isMine(clicked)) {
			setPiece(clicked, Piece.MINE_RED);
		}

		// show mines on the board
		for (Space space : getAllSpaces()) {
			if (space.equals(clicked)) {
				continue;
			}
			Piece piece = getPiece(space);
			if (isMine(space)) {
				// but only on empty or marks
				if (piece == null || piece.isMark()) {
					setPiece(space, mine);
				}
			} else {
				// if the space has a flag but no mine, mark it as such
				if (piece == Piece.FLAG) {
					setPiece(space, Piece.FLAG_NOT);
				}
			}
		}
	}

	/* Clicking */

	/**
	 * Handle standard game clicks
	 * 
	 * @param space  Space clicked
	 * @param action Type of click
	 */
	
	public void handleClick(Space space, ClickAction action) {
		// stop playing when the game is over
		if (gameOver) {
			return;
		}
		// simply passes it along to the dedicated function
		switch (action) {
		case DEFAULT:
			handleDefaultClick(space);
			break;
		case FLAG:
			handleFlagClick(space);
			break;
		case MARK:
			handleMarkClick(space);
			break;
		case CHEAT:
			handleCheatClick(space);
			break;
		}
	}

	/**
	 * Space clicking core, does the actual clicking action
	 * 
	 * @param space Space clicked
	 */
	
	private void clickSpace(Space space) {
		// if the space is not replaceable, stop now
		// called here so we don't click flags as they are mines
		if (!isReplaceable(space)) {
			return;
		}

		// if the space is a mine, we lose
		if (isMine(space)) {
			loseGame(space);
		}

		// otherwise do a normal click
		else {
			// sets the piece to the number of surrounding mines
			Piece newPiece = getNumber(space);
			setPiece(space, newPiece);

			// if the piece is 0, update surrounding pieces as none of them are mines
			// this won't eternally recur since this space is no longer clickable
			if (newPiece == Piece.N0) {
				for (Space neighbor : getNeighbors(space)) {
					clickSpace(neighbor);
				}
			}
		}
	}

	/**
	 * Default clicks, clicks a space and displays a number or loses the game
	 * 
	 * @param space Space clicked
	 */
	
	private void handleDefaultClick(Space space) {
		// first click should generate the minefield
		if (!firstClick) {
			firstClick(space);
		}

		// if the space cannot be replaced then stop here
		// as we run this function on every click
		if (isNumber(space)) {
			// if the number of flags around this space is the same as the number
			Space[] neighbors = getNeighbors(space);

			// count the flags around the piece
			int flags = 0;
			for (Space neighbor : neighbors) {
				if (getPiece(neighbor) == Piece.FLAG) {
					flags++;
				}
			}

			// same number of flags as the piece number?
			if (flags == getPiece(space).getNumber()) {
				// click all the spaces. This is a risky move if a flag is wrong
				for (Space neighbor : neighbors) {
					clickSpace(neighbor);
				}
			}
		}
		// otherwise if not a number, just click the space
		else {
			clickSpace(space);
		}

		// check just once at the end of clicking
		checkVictory();
	}

	/**
	 * Handle the first click in the game. This click will generate the minefield as
	 * it cannot be on a mine
	 * 
	 * @param space Space clicked
	 */
	
	private void firstClick(Space space) {
		generateMines(space);
		firstClick = true;
	}

	/**
	 * Flag clicks, essentially click once to add
	 * 
	 * @param space Space clicked
	 */
	
	private void handleFlagClick(Space space) {
		// if already a flag, set a mark
		Piece piece = getPiece(space);
		if (piece == Piece.FLAG) {
			setPiece(space, Piece.MARK_RED);
			flagCount--;
		}
		// remove marks
		else if (piece != null && piece.isMark()) {
			setPiece(space, null);
		}
		// otherwise if we can add one
		else if (isReplaceable(space)) {
			if(flagCount < data.mineCount) {
				setPiece(space, Piece.FLAG);
				flagCount++;
			}
		}
		
		checkVictory();
	}

	/**
	 * Mark clicks, changes the color of a mark
	 * 
	 * @param space Space clicked
	 */
	
	private void handleMarkClick(Space space) {
		// toggle the mark
		Piece piece = getPiece(space);
		if (piece == Piece.MARK_RED) {
			setPiece(space, Piece.MARK_GREEN);
		}
		// remove marks
		else if (piece == Piece.MARK_GREEN) {
			setPiece(space, Piece.MARK_BLUE);
		}
		// otherwise if we can add one
		else if (piece == Piece.MARK_BLUE) {
			setPiece(space, Piece.MARK_RED);
		}

		// if its a flag, remove it
		else if (piece == Piece.FLAG) {
			setPiece(space, Piece.MARK_RED);
			flagCount--;
		}

		// essentially all that is left here is null, but still
		else if (isReplaceable(space)) {
			setPiece(space, Piece.MARK_RED);
		}
	}

	/**
	 * Cheat clicks, click a space and it will show a "ghost" bomb if one exists
	 * 
	 * @param space Space clicked
	 */
	
	private void handleCheatClick(Space space) {
		// already ran, don't run again
		if (!canCheat()) {
			return;
		}

		// no mines if we have not clicked
		if (!firstClick) {
			// you cheated for the first click, useless move as now we don't care
			// about click protection
			firstClick(null);
		}

		// only marks and empty spaces can be cheated, to save accidental clicks
		Piece piece = getPiece(space);
		if (piece != null && !piece.isMark()) {
			return;
		}

		// if its a mine, show that
		if (isMine(space)) {
			setPiece(space, Piece.MINE_GREEN);
		}
		// otherwise click the space as we know its safe
		else {
			clickSpace(space);
		}

		// use a cheat
		cheats--;

		// need to check, since it could be the last click
		checkVictory();
	}

	/* Helper functions */

	/**
	 * Gets a list of all spaces
	 * 
	 * @return a list of all spaces
	 */
	
	public Space[] getAllSpaces() {
		Space[] spaces = new Space[width * height];

		// loop through all spaces, adding them to an array
		int i = 0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				spaces[i] = new Space(x, y);
				i++;
			}
		}

		return spaces;
	}

	/**
	 * Helper function to get the coordinates of all 8 neighbors to the space Note
	 * that some may be invalid spaces
	 * 
	 * @param space Space around which to get neighbors
	 * @return an array of spaces of the 8 neighbors, or less on edges
	 */
	
	public Space[] getNeighbors(Space space) {
		// if not valid, return no neighbors
		if (!isValid(space)) {
			return new Space[0];
		}

		// array cannot be bigger than 8
		Space[] neighbors = new Space[8];
		int x = space.getX();
		int y = space.getY();

		// 2D loop from x - 1, y - 1 up to x + 1, y + 1
		int neighborCount = 0;
		for (int i = -1; i <= 1; i++) {
			for (int j = -1; j <= 1; j++) {
				// skip offset of 0,0 as that is the input space
				if (i == 0 && j == 0) {
					continue;
				}

				// make sure the space is valid before returning it
				Space neighbor = new Space(x + i, y + j);
				if (isValid(neighbor)) {
					neighbors[neighborCount] = neighbor;
					neighborCount++;
				}
			}
		}

		return neighbors;
	}

	/**
	 * Marks a space as needing update by the graphics display
	 * 
	 * @param space space needing an update
	 */
	
	public void markUpdate(Space space) {
		if (!update.contains(space)) {
			update.add(space);
		}
	}

	/**
	 * Returns the number to display on the space after clicking it Does not take
	 * bombs on this space into account, check isMine() first
	 * 
	 * @param space Space to check
	 * @return The number of bombs around this space
	 */
	
	public Piece getNumber(Space space) {
		// no space? no return
		if (!isValid(space)) {
			return null;
		}

		int count = 0;
		// check all the neighbors for a bomb
		for (Space neighbor : getNeighbors(space)) {
			// if they have one, add to the running total
			if (isMine(neighbor)) {
				count++;
			}
		}

		// return the specific piece
		return Piece.fromNumber(count);
	}

	/* Getters, setters, and basic return logic */

	/**
	 * Gets the piece on the specified space
	 * 
	 * @param space Space to check for a piece
	 * @return the piece on the specified space
	 */
	
	public Piece getPiece(Space space) {
		// invalid gets null
		if (!isValid(space)) {
			return null;
		}

		// otherwise go with the contained piece
		return pieces[space.getY()][space.getX()];
	}

	/**
	 * Placed a piece on a space
	 * 
	 * @param space Space to place the piece
	 * @param piece Piece to place on the space
	 */
	
	public void setPiece(Space space, Piece piece) {
		// must be valid
		if (isValid(space)) {
			pieces[space.getY()][space.getX()] = piece;
			markUpdate(space);
		}
	}

	/**
	 * Determines if a space contains a bomb
	 * 
	 * @param space Space to check
	 * @return True if the space contains a bomb
	 */
	
	public boolean isMine(Space space) {
		// not a valid space?
		if (!isValid(space)) {
			return false;
		}

		return mines[space.getY()][space.getX()];
	}

	/**
	 * Determines if a space appears enabled, or pressed up
	 * 
	 * @param space Space to check
	 * @return True if the space appears enabled
	 */
	
	public boolean isEnabled(Space space) {
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it pops up
		if (piece == null) {
			return true;
		}

		// otherwise go based on the contained value
		return piece.isEnabled();
	}

	/**
	 * Determines if the contents of a space can be replaced
	 * 
	 * @param space Space clicked
	 */
	
	private boolean isReplaceable(Space space) {
		// invalid spaces are always false
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it can be clicked
		if (piece == null) {
			return true;
		}

		// otherwise go based on the contained value
		return piece.isReplaceable();
	}

	/**
	 * Determines if the space is a number
	 * 
	 * @param space Space clicked
	 */
	
	private boolean isNumber(Space space) {
		// invalid spaces are always false
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it is not a number
		if (piece == null) {
			return false;
		}

		// otherwise go based on the contained value
		return piece.isNumber();
	}

	/* Data */

	/**
	 * Gets the width of the board
	 * 
	 * @return The width of the board
	 */
	
	public int getWidth() {
		return width;
	}

	/**
	 * Gets the height of the board
	 * 
	 * @return The height of the board
	 */
	
	public int getHeight() {
		return height;
	}

	/**
	 * Gets the number of mines left on the board
	 * 
	 * @return number of mines remaining
	 */
	
	public int getRemainingMines() {
		return data.mineCount - flagCount;
	}

	/**
	 * Checks if the player has used their cheat
	 * 
	 * @return if the player has used their cheat
	 */
	
	public boolean canCheat() {
		return cheats > 0;
	}

	/**
	 * Checks how many cheats the player has left
	 * 
	 * @return remaining cheats
	 */
	
	public int getCheats() {
		return cheats;
	}

	/**
	 * Checks if the game ended
	 * 
	 * @return true if the game ended
	 */
	
	public boolean gameOver() {
		return gameOver;
	}

	/**
	 * Checks if the player won the game
	 * 
	 * @return true if the player won the game
	 */
	
	public boolean hasWon() {
		return victory;
	}

	/**
	 * Checks if a space is within the bounds of this board
	 * 
	 * @param space Space to check
	 * @return true if the space is within this board
	 */
	
	public boolean isValid(Space space) {
		// no space?
		if (space == null) {
			return false;
		}

		// first, check if the space is entirely invalid
		if (space.getX() < 0 || space.getY() < 0) {
			return false;
		}

		// next, check if this is outside of this board
		if (space.getY() >= height || space.getX() >= width) {
			return false;
		}

		// fits in both? return true then
		return true;
	}

	/**
	 * Gets a list of spaces pending updates to update the button displays
	 * 
	 * @return a list of spaces needing an update
	 */
	
	public Queue<Space> getUpdates() {
		return update;
	}

	/**
	 * Actions that can be performed on click. Used by buttons to pass along a
	 * constant rather than a list of modifiers.
	 */
	
	public enum ClickAction {
		/** Normal click */
		DEFAULT,
		/** Placing a flag or mark */
		FLAG,
		/** Placing a mark of different colors */
		MARK,
		/** Safely clicking a mine */
		CHEAT;
	}
}
]]></text>
  </DocumentChange>
  <DocumentChange __id="201" _type="Insert" docASTNodeCount="1772" docActiveCodeLength="10613" docExpressionCount="1042" docLength="19639" length="19128" offset="520" timestamp="1332234">
    <text><![CDATA[parate
	 * object created using a specific seed
	 */
	
	public static final Random RANDOM = new Random();

	// resizable
	private transient Queue<Space> update;

	// board dimensions
	private int width, height;
	private MineGenerator data = new MineGenerator();

	private int flagCount;

	// board data
	private Piece[][] pieces;
	private boolean[][] mines;
	private boolean gameOver;
	private boolean victory;

	// determines if the first click happened yet
	private boolean firstClick;

	// determines if we have used our one cheat
	private int cheatsAllowed;
	private int cheats = 0;

	// board seed
	private long seed;

	/**
	 * Creates a new minesweaper board with the specified dimensions
	 * 
	 * @param width     Width of the board
	 * @param height    Height of the board
	 * @param mineCount Total mines
	 * @param cheats    Cheats allowed
	 */
	
	public MineSweeperBoard(int width, int height, int mineCount, int cheats) {
		this.width = width;
		this.height = height;

		this.pieces = new Piece[height][width];
		this.mines = new boolean[height][width];

		// sanity check in case the GUI fails to correct the number
		this.data.mineCount = Math.min(mineCount, width * height - 9);
		this.cheatsAllowed = this.cheats = cheats;

		update = new LinkedList<>();
	}

	/**
	 * Creates a new minesweaper board with the specified dimensions
	 * 
	 * @param width     Width of the board
	 * @param height    Height of the board
	 * @param mineCount Total mines
	 */
	
	public MineSweeperBoard(int width, int height, int mineCount) {
		this(width, height, mineCount, 1);
	}

	/* Main logic */

	/**
	 * Populates the board with mines with a random seed
	 * 
	 * @param space Space clicked
	 */
	
	public void generateMines(Space space) {
		generateMines(RANDOM.nextLong(), space);
	}

	/**
	 * Populates the board with mines
	 * 
	 * @param seed    Seed to generate mines. Two fields with the same size and seed
	 *                will have the same mines locations
	 * @param clicked space clicked when generating the mines
	 */
	
	protected void generateMines(long seed, Space clicked) {
		// store the current seed for saving games
		this.seed = seed;

		// no mines? no work
		if (data.mineCount == 0) {
			return;
		}

		// list of spaces we can still place a mine at
		List<Space> remainingSpaces = new ArrayList<>(Arrays.asList(getAllSpaces()));

		// if we clicked somewhere, remove all nearby spaces
		if (clicked != null) {
			// remove all unclickable spaces
			final int x = clicked.getX(), y = clicked.getY();
			remainingSpaces.removeIf((space) -> {
				return (y - 1) <= space.getY() && space.getY() <= (y + 1) && (x - 1) <= space.getX()
						&& space.getX() <= (x + 1);
			});
		}

		// random object seeded so results can be controlled
		Random random = new Random(seed);

		// place mines
		this.mines = new boolean[height][width];
		for (int i = 0; i < data.mineCount; i++) {
			// just get the linear location of the next mine and place it
			int mine = random.nextInt(remainingSpaces.size());
			Space space = remainingSpaces.get(mine);
			mines[space.getY()][space.getX()] = true;
			remainingSpaces.remove(mine);
		}
	}

	/**
	 * Creates a new game with the same dimensions
	 */
	
	public void newGame() {
		// first, regenerate the mines
		this.mines = new boolean[height][width];

		// next, clear game specific data
		resetData();

		// then mark all spaces for a rendering update
		for (Space space : getAllSpaces()) {
			markUpdate(space);
		}
	}

	/**
	 * Restarts the current game
	 */
	
	public void restart() {
		// if we have not clicked yet, do nothing
		// we don't have a seed to restart from
		if (!firstClick) {
			return;
		}

		// reset any relevant data
		resetData();

		// but assume we already clicked so the mines don't change
		firstClick = true;

		// and mark all spaces for an update
		for (Space space : getAllSpaces()) {
			markUpdate(space);
		}
	}

	/**
	 * Saves the board to a binary file
	 * 
	 * @param filename Location of the game
	 */
	
	public void saveGame(String filename) {
		// TODO: better saving logic
		try {
			FileOutputStream file = new FileOutputStream(filename + ".bin");
			ObjectOutputStream stream = new ObjectOutputStream(file);
			stream.writeObject(this);
			stream.flush();
			stream.close();
		} catch (IOException e) {
		}
	}

	/**
	 * Load the board from a binary file
	 * 
	 * @param filename Location of the game
	 * @return The board, or null if invalid
	 */
	
	public static MineSweeperBoard loadGame(String filename) {
		try {
			FileInputStream file = new FileInputStream(filename + ".bin");
			ObjectInputStream stream = new ObjectInputStream(file);
			MineSweeperBoard board = (MineSweeperBoard) stream.readObject();
			stream.close();
			return board;
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Resets generic data
	 */
	
	private void resetData() {
		this.pieces = new Piece[height][width];
		gameOver = false;
		firstClick = false;
		cheats = cheatsAllowed;
		flagCount = 0;
		victory = false;
	}

	/**
	 * Ends the game with a loss
	 * 
	 * @param clicked Location clicked causing the loss
	 * @return Mine clicked
	 */
	
	public void loseGame(Space clicked) {
		// set the game to over
		gameOver = true;

		showMines(clicked, false);
	}

	/**
	 * Checks if the game has been won, and sets the appropiate statuses
	 */
	
	public void checkVictory() {
		// check all spaces
		for (Space space : getAllSpaces()) {

			// only spaces without mines need to be checked, we don't care about
			// flags or marks on mine spaces
			if (!isMine(space)) {
				// if the piece is unclicked or not a number, we failed
				Piece piece = getPiece(space);
				if (piece == null || !piece.isNumber()) {
					return;
				}
			}
		}

		// made it through that? we won
		victory = true;
		gameOver = true;

		showMines(null, true);
	}

	/**
	 * Shows all the mines on the board
	 * 
	 * @param space   Space that was clicked
	 * @param victory Determines if the game was won or lost
	 */
	
	private void showMines(Space clicked, boolean victory) {
		// set the mine color based on victory
		Piece mine = victory ? Piece.MINE_GREEN : Piece.MINE;

		// set the clicked space to red
		if (clicked != null && isMine(clicked)) {
			setPiece(clicked, Piece.MINE_RED);
		}

		// show mines on the board
		for (Space space : getAllSpaces()) {
			if (space.equals(clicked)) {
				continue;
			}
			Piece piece = getPiece(space);
			if (isMine(space)) {
				// but only on empty or marks
				if (piece == null || piece.isMark()) {
					setPiece(space, mine);
				}
			} else {
				// if the space has a flag but no mine, mark it as such
				if (piece == Piece.FLAG) {
					setPiece(space, Piece.FLAG_NOT);
				}
			}
		}
	}

	/* Clicking */

	/**
	 * Handle standard game clicks
	 * 
	 * @param space  Space clicked
	 * @param action Type of click
	 */
	
	public void handleClick(Space space, ClickAction action) {
		// stop playing when the game is over
		if (gameOver) {
			return;
		}
		// simply passes it along to the dedicated function
		switch (action) {
		case DEFAULT:
			handleDefaultClick(space);
			break;
		case FLAG:
			handleFlagClick(space);
			break;
		case MARK:
			handleMarkClick(space);
			break;
		case CHEAT:
			handleCheatClick(space);
			break;
		}
	}

	/**
	 * Space clicking core, does the actual clicking action
	 * 
	 * @param space Space clicked
	 */
	
	private void clickSpace(Space space) {
		// if the space is not replaceable, stop now
		// called here so we don't click flags as they are mines
		if (!isReplaceable(space)) {
			return;
		}

		// if the space is a mine, we lose
		if (isMine(space)) {
			loseGame(space);
		}

		// otherwise do a normal click
		else {
			// sets the piece to the number of surrounding mines
			Piece newPiece = getNumber(space);
			setPiece(space, newPiece);

			// if the piece is 0, update surrounding pieces as none of them are mines
			// this won't eternally recur since this space is no longer clickable
			if (newPiece == Piece.N0) {
				for (Space neighbor : getNeighbors(space)) {
					clickSpace(neighbor);
				}
			}
		}
	}

	/**
	 * Default clicks, clicks a space and displays a number or loses the game
	 * 
	 * @param space Space clicked
	 */
	
	private void handleDefaultClick(Space space) {
		// first click should generate the minefield
		if (!firstClick) {
			firstClick(space);
		}

		// if the space cannot be replaced then stop here
		// as we run this function on every click
		if (isNumber(space)) {
			// if the number of flags around this space is the same as the number
			Space[] neighbors = getNeighbors(space);

			// count the flags around the piece
			int flags = 0;
			for (Space neighbor : neighbors) {
				if (getPiece(neighbor) == Piece.FLAG) {
					flags++;
				}
			}

			// same number of flags as the piece number?
			if (flags == getPiece(space).getNumber()) {
				// click all the spaces. This is a risky move if a flag is wrong
				for (Space neighbor : neighbors) {
					clickSpace(neighbor);
				}
			}
		}
		// otherwise if not a number, just click the space
		else {
			clickSpace(space);
		}

		// check just once at the end of clicking
		checkVictory();
	}

	/**
	 * Handle the first click in the game. This click will generate the minefield as
	 * it cannot be on a mine
	 * 
	 * @param space Space clicked
	 */
	
	private void firstClick(Space space) {
		generateMines(space);
		firstClick = true;
	}

	/**
	 * Flag clicks, essentially click once to add
	 * 
	 * @param space Space clicked
	 */
	
	private void handleFlagClick(Space space) {
		// if already a flag, set a mark
		Piece piece = getPiece(space);
		if (piece == Piece.FLAG) {
			setPiece(space, Piece.MARK_RED);
			flagCount--;
		}
		// remove marks
		else if (piece != null && piece.isMark()) {
			setPiece(space, null);
		}
		// otherwise if we can add one
		else if (isReplaceable(space)) {
			if(flagCount < data.mineCount) {
				setPiece(space, Piece.FLAG);
				flagCount++;
			}
		}
	}

	/**
	 * Mark clicks, changes the color of a mark
	 * 
	 * @param space Space clicked
	 */
	
	private void handleMarkClick(Space space) {
		// tobble the mark
		Piece piece = getPiece(space);
		if (piece == Piece.MARK_RED) {
			setPiece(space, Piece.MARK_GREEN);
		}
		// remove marks
		else if (piece == Piece.MARK_GREEN) {
			setPiece(space, Piece.MARK_BLUE);
		}
		// otherwise if we can add one
		else if (piece == Piece.MARK_BLUE) {
			setPiece(space, Piece.MARK_RED);
		}

		// if its a flag, remove it
		else if (piece == Piece.FLAG) {
			setPiece(space, Piece.MARK_RED);
			flagCount--;
		}

		// essentially all that is left here is null, but still
		else if (isReplaceable(space)) {
			setPiece(space, Piece.MARK_RED);
		}
	}

	/**
	 * Cheat clicks, click a space and it will show a "ghost" bomb if one exists
	 * 
	 * @param space Space clicked
	 */
	
	private void handleCheatClick(Space space) {
		// already ran, don't run again
		if (!canCheat()) {
			return;
		}

		// no mines if we have not clicked
		if (!firstClick) {
			// you cheated for the first click, useless move as now we don't care
			// about click protection
			firstClick(null);
		}

		// only marks and empty spaces can be cheated, to save accidental clicks
		Piece piece = getPiece(space);
		if (piece != null && !piece.isMark()) {
			return;
		}

		// if its a mine, show that
		if (isMine(space)) {
			setPiece(space, Piece.MINE_GREEN);
		}
		// otherwise click the space as we know its safe
		else {
			clickSpace(space);
		}

		// use a cheat
		cheats--;

		// need to check, since it could be the last click
		checkVictory();
	}

	/* Helper functions */

	/**
	 * Gets a list of all spaces
	 * 
	 * @return a list of all spaces
	 */
	
	public Space[] getAllSpaces() {
		Space[] spaces = new Space[width * height];

		// loop through all spaces, adding them to an array
		int i = 0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				spaces[i] = new Space(x, y);
				i++;
			}
		}

		return spaces;
	}

	/**
	 * Helper function to get the coordinates of all 8 neighbors to the space Note
	 * that some may be invalid spaces
	 * 
	 * @param space Space around which to get neighbors
	 * @return an array of spaces of the 8 neighbors, or less on edges
	 */
	
	public Space[] getNeighbors(Space space) {
		// if not valid, return no neighbors
		if (!isValid(space)) {
			return new Space[0];
		}

		// array cannot be bigger than 8
		Space[] neighbors = new Space[8];
		int x = space.getX();
		int y = space.getY();

		// 2D loop from x - 1, y - 1 up to x + 1, y + 1
		int neighborCount = 0;
		for (int i = -1; i <= 1; i++) {
			for (int j = -1; j <= 1; j++) {
				// skip offset of 0,0 as that is the input space
				if (i == 0 && j == 0) {
					continue;
				}

				// make sure the space is valid before returning it
				Space neighbor = new Space(x + i, y + j);
				if (isValid(neighbor)) {
					neighbors[neighborCount] = neighbor;
					neighborCount++;
				}
			}
		}

		return neighbors;
	}

	/**
	 * Marks a space as needing update by the graphics display
	 * 
	 * @param space space needing an update
	 */
	
	public void markUpdate(Space space) {
		if (!update.contains(space)) {
			update.add(space);
		}
	}

	/**
	 * Returns the number to display on the space after clicking it Does not take
	 * bombs on this space into account, check isMine() first
	 * 
	 * @param space Space to check
	 * @return The number of bombs around this space
	 */
	
	public Piece getNumber(Space space) {
		// no space? no return
		if (!isValid(space)) {
			return null;
		}

		int count = 0;
		// check all the neighbors for a bomb
		for (Space neighbor : getNeighbors(space)) {
			// if they have one, add to the running total
			if (isMine(neighbor)) {
				count++;
			}
		}

		// return the specific piece
		return Piece.fromNumber(count);
	}

	/* Getters, setters, and basic return logic */

	/**
	 * Gets the piece on the specified space
	 * 
	 * @param space Space to check for a piece
	 * @return the piece on the specified space
	 */
	
	public Piece getPiece(Space space) {
		// invalid gets null
		if (!isValid(space)) {
			return null;
		}

		// otherwise go with the contained piece
		return pieces[space.getY()][space.getX()];
	}

	/**
	 * Placed a piece on a space
	 * 
	 * @param space Space to place the piece
	 * @param piece Piece to place on the space
	 */
	
	public void setPiece(Space space, Piece piece) {
		// must be valid
		if (isValid(space)) {
			pieces[space.getY()][space.getX()] = piece;
			markUpdate(space);
		}
	}

	/**
	 * Determines if a space contains a bomb
	 * 
	 * @param space Space to check
	 * @return True if the space contains a bomb
	 */
	
	public boolean isMine(Space space) {
		// not a valid space?
		if (!isValid(space)) {
			return false;
		}

		return mines[space.getY()][space.getX()];
	}

	/**
	 * Determines if a space appears enabled, or pressed up
	 * 
	 * @param space Space to check
	 * @return True if the space appears enabled
	 */
	
	public boolean isEnabled(Space space) {
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it pops up
		if (piece == null) {
			return true;
		}

		// otherwise go based on the contained value
		return piece.isEnabled();
	}

	/**
	 * Determines if the contents of a space can be replaced
	 * 
	 * @param space Space clicked
	 */
	
	private boolean isReplaceable(Space space) {
		// invalid spaces are always false
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it can be clicked
		if (piece == null) {
			return true;
		}

		// otherwise go based on the contained value
		return piece.isReplaceable();
	}

	/**
	 * Determines if the space is a number
	 * 
	 * @param space Space clicked
	 */
	
	private boolean isNumber(Space space) {
		// invalid spaces are always false
		if (!isValid(space)) {
			return false;
		}

		Piece piece = getPiece(space);

		// if the space is empty, it is not a number
		if (piece == null) {
			return false;
		}

		// otherwise go based on the contained value
		return piece.isNumber();
	}

	/* Data */

	/**
	 * Gets the width of the board
	 * 
	 * @return The width of the board
	 */
	
	public int getWidth() {
		return width;
	}

	/**
	 * Gets the height of the board
	 * 
	 * @return The height of the board
	 */
	
	public int getHeight() {
		return height;
	}

	/**
	 * Gets the number of mines left on the board
	 * 
	 * @return number of mines remaining
	 */
	
	public int getRemainingMines() {
		return data.mineCount - flagCount;
	}

	/**
	 * Checks if the player has used their cheat
	 * 
	 * @return if the player has used their cheat
	 */
	
	public boolean canCheat() {
		return cheats > 0;
	}

	/**
	 * Checks how many cheats the player has left
	 * 
	 * @return remaining cheats
	 */
	
	public int getCheats() {
		return cheats;
	}

	/**
	 * Checks if the game ended
	 * 
	 * @return true if the game ended
	 */
	
	public boolean gameOver() {
		return gameOver;
	}

	/**
	 * Checks if the player won the game
	 * 
	 * @return true if the player won the game
	 */
	
	public boolean hasWon() {
		return victory;
	}

	/**
	 * Checks if a space is within the bounds of this board
	 * 
	 * @param space Space to check
	 * @return true if the space is within this board
	 */
	
	public boolean isValid(Space space) {
		// no space?
		if (space == null) {
			return false;
		}

		// first, check if the space is entirely invalid
		if (space.getX() < 0 || space.getY() < 0) {
			return false;
		}

		// next, check if this is outside of this board
		if (space.getY() >= height || space.getX() >= width) {
			return false;
		}

		// fits in both? return true then
		return true;
	}

	/**
	 * Gets a list of spaces pending updates to update the button displays
	 * 
	 * @return a list of spaces needing an update
	 */
	
	public Queue<Space> getUpdates() {
		return update;
	}

	/**
	 * Actions that can be performed on click. Used by buttons to pass along a
	 * constant rather than a list of modifiers.
	 */
	
	public enum ClickAction {
		/** Normal click */
		DEFAULT,
		/** Placing a flag or mark */
		FLAG,
		/** Placing a mark of different colors */
		MARK,
		/** Safely clicking a mine */
		CHEAT;
	}
}
]]></text>
  </DocumentChange>
  <Command __id="202" _type="FileOpenCommand" docASTNodeCount="260" docActiveCodeLength="2374" docExpressionCount="151" docLength="3861" projectName="MineSweeper" timestamp="1335216">
    <filePath><![CDATA[C:\Users\Eye-tracking\git\MineSweeper-Experiment\src\logic\MineSweeper.java]]></filePath>
  </Command>
  <Command __id="203" _type="MoveCaretCommand" caretOffset="604" docOffset="707" timestamp="1335296" />
  <Command __id="204" _type="ShellBoundsCommand" bounds="[-8, -8, 1936, 1056]" timestamp="1341336" />
</Events>
